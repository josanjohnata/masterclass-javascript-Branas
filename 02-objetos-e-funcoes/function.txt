# Function
  - Uma função é um objeto que contém um bloco de código executável
    Ex.: 
      function sum(a, b) { (Essa forma de declarar uma função é conhecida como function declaration)
        return a + b;
      };
      console.log(sum(2, 2)); -> 4

      const sum = function(a, b) { (Essa forma de declarar uma função é conhecida como function expression)
        return a + b;
      };
      console.log(sum(2, 2)); -> 4
  - Qual é a diferença entre function declaration e expression?
    - A function declaration pode ser ser invocada antes da declaração e a function expression não permite isso.
  - Na linguagem JavaScript, as funções são de primeira classe, ou seja, podem ser atribuídas a uma variável,
    passadas por parâmetro ou serem retornada de uma outra função
    Ex.: 
      const sum = function(a, b) {
        return a + b;
      }

      const subtract = function(a, b) {
        return a - b;
      }

      const calculator = function(fn) {
        return function(a, b) {
          return fn(a, b);
        }
      }

      console.log(sum(2, 2)); -> 4
      console.log(subtract(2, 2)); -> 0
      console.log(calculator(sun)(2, 2)); -> 4
      console.log(calculator(subtract)(2, 2)); -> 0
  - É possível invocar uma função com menos ou mais parâmetros, não necessariamente seguindo o que está declarado
    Ex.: 
      const sum = function(a, b) {
        return a + b;
      }
      console.log(sum(2, 2)); -> 4
      console.log(sum(2)); -> NaN -> o JavaScript preenche o segundo parâmetro como undefined, e ao somar 2 + undefined = NaN
      console.log(sum(2, 2, 3)); -> 4 -> Quando se passa mais parâmetros do que a função está esperando, o JavaScript ignora os demais parâmetros
  - Podemos definir valores padrão para cada um dos parâmetros de uma função
    Ex.: 
      const sum = function(a = 1, b = 1) {
        return a + b;
      }
      console.log(sum(2, 2)); -> 4
      console.log(sum(2)); -> 3
      console.log(sum()); -> 2
  - Por meio da variável implícita arguments é possível acessar os parâmetros da função invocada
    Ex.:
      const sum = function() {
        console.log(arguments);
      };

      sum(1, 2, 3, 4, 5, 6, 7, 8, 9); -> { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5, '5': 6, '6': 7, '7': 8, '8': 9 }
    Ex.:
      const sum = function() {
        let total = 0;
        for (let argument in arguments) {
          total += arguments[argument];
        }
        return total;
      };
      console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)); -> 45
  - Também é possível acessar os parâmetros da função invocada por meio do rest parameter
    Ex.:
      const sum = function(...numbers) {
        let total = 0;
        for (let number of numbers) {
          total += number;
        }
        return total;
      };
      console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)); -> 45
  - CUIDADO! O rest parameter deve ser sempre o último da lista de parâmetros

# This
  - Existe uma variável implícita chamada de this que faz referência para o objeto responsável pela sua invocação
    Ex.:
      const rectangle = {
        x: 10,
        y: 2'
        calculateArea() {
          return this.x * this.y;
        }
      };
      console.log(rectangle.calculateArea); -> 20

# getter e setter
  - As funções do tipo getter e setter servem para interceptar o acesso as propriedades de um determinado objeto
    Ex.:
      const rectangle = {
        set x(x) {
          if (x > 0) {
            this._x = x;
          } else {
            console.log("Invalid value for x");
          }
        },
        set y(y) {
          if (y > 0) {
            this._y = y;
          } else {
            console.log("Invalid value for y");
          }
        },
        get area() {
          return this._x * this._y;
        }
      };
      rectangle.x = 10;
      rectangle.y = 2;
      console.log(rectangle.area); -> 20
  - CUIDADO! Sempre utilize chaves diferentes para a função getter e a propriedade do objeto
  - Por meio da operação defineProperty da Object API, também é possível definir funções do tipo getter e setter
    Ex.:
      const rectangle = {};
      Object.defineProperty(rectangle, "x", {
        set(x) {
          if (x > 0) {
            this._x = x;
          } else {
            console.log("Invalid value for x");
          }
        }
      });
      Object.defineProperty(rectangle, "y", {
        set(y) {
          if (y > 0) {
            this._y = y;
          } else {
            console.log("Invalid value for y");
          }
        }
      });
      Object.defineProperty(rectangle, "area", {
        get() {
          return this._x * this._y
        }
      });
      rectangle.x = 10;
      rectangle.y = 2;
      console.log(rectangle.area); -> 20
  - CUIDADO! Sempre utilize chaves diferentes para a função setter e a propriedade do objeto

# call, apply e bind
  - Por meio das operações call e apply é possível invocar uma função passando o this por parâmetro
    Ex.:
      const calculateArea = function() {
        return Math.PI * Math.pow(this.radius, 2);
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      console.log(calculateArea.call(circle)); -> 314.1592653589793
      console.log(calculateArea.apply(circle)); -> 314.1592653589793
  - Qual é a diferença entre call e apply? Basicamente a diferença entre ele é a forma de como passar os parâmetros
    Ex.:
      const calculateArea = function(fn) {
        return fn(Math.PI * Math.pow(this.radius, 2));
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      console.log(calculateArea.call(circle, Math.round)); -> 314
      console.log(calculateArea.apply(circle, [Math.ceil])); -> 314
  - A operação bind permite encapsular o this dentro da função, retornando-a
    Ex.:
      const calculateArea = function(fn) {
        return fn(Math.PI * Math.pow(this.radius, 2));
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      const calculateAreaForCircle = calculateArea.bind(circle);
      console.log(calculateAreaForCircle(Math.round)); -> 314
      console.log(calculateAreaForCircle(Math.ceil)); -> 314

# new
  Ex.: 
    const person1 = {
      name: "Linus Torvalds",
      city: "Helsinki",
      year: 1969,
      getAge() {
        return (new Date()).getFullYear() - this.year;
      }
    };
    const person2 = {
      name: "Bill Gates",
      city: "Seattle",
      year: 1955,
      getAge() {
        return (new Date()).getFullYear() - this.year;
      }
    };
    console.log(person1);
    console.log(person1.getAge());
    console.log(person2);
    console.log(person2.getAge());
  - Como fazer para criar um objeto a partir da mesma estrutura?
  - A função fábrica, que é um tipo de padrão, retorna um novo objeto após ser invocada diretamente
    Ex.:
      const createPerson = function(name, city, year) {
        return {
            name,
            city,
            year,
            getAge() {
              return (new Date()).getFullYear() - this year;
            }
        };
      };
      const person1 = createPerson("Linus Torvalds", "Helsinki", 1969);
      const person2 = createPerson("Bill Gates", "Seattle", 1955);
  - O que fazer para eliminar a duplicação e reusar propriedades entre os objetos?
    Ex.:
      const personPrototype = {
        getAge() {
          return (new Date()).getFullYear() - this year;
        }
      };
      const createPerson = function(name, city, year) {
        const person = {
            name,
            city,
            year,
        };
        Object.setPrototypeOf(person, personPrototype);
        return person;
      };
      const person1 = createPerson("Linus Torvalds", "Helsinki", 1969);
      const person2 = createPerson("Bill Gates", "Seattle", 1955);
  - A função construtora retorna um novo objeto ao ser invocada por meio do operador new
    Ex.:
    // Script do operador new
    const _new = function(fn, ...params) {
      const obj = {};
      Object.setPrototypeOf(obj, fn.prototype);
      fn.apply(obj, params);
      return obj;
    };
      const Person = function(name, city, year) {
        this.name = name;
        this.city = city;
        this.year = year;
        this.getAge = function() {
          return (new Date()).getFullYear() - this year;
        }
      };
      const person1 = _new(Person, "Linus Torvalds", "Helsinki", 1969);
      const person2 = _new(Person, "Bill Gates", "Seattle", 1955);
  - Toda função tem uma propriedade chamada prototype, que é vinculada ao __proto__ do objeto criado pelo operador new
    Ex.:
      const Person = function(name, city, year) {
        this.name = name;
        this.city = city;
        this.year = year;
      };
      Person.prototype.getAge = function() {
          return (new Date()).getFullYear() - this year;
        }
      const person1 = new Person("Linus Torvalds", "Helsinki", 1969);
      const person2 = new Person("Bill Gates", "Seattle", 1955);
  - CUIDADO! Não esqueça de utilizar o operador new quando utilizar funções construtoras
