# Function
  - Uma função é um objeto que contém um bloco de código executável
    Ex.: 
      function sum(a, b) { (Essa forma de declarar uma função é conhecida como function declaration)
        return a + b;
      };
      console.log(sum(2, 2)); -> 4

      const sum = function(a, b) { (Essa forma de declarar uma função é conhecida como function expression)
        return a + b;
      };
      console.log(sum(2, 2)); -> 4
  - Qual é a diferença entre function declaration e expression?
    - A function declaration pode ser ser invocada antes da declaração e a function expression não permite isso.
  - Na linguagem JavaScript, as funções são de primeira classe, ou seja, podem ser atribuídas a uma variável,
    passadas por parâmetro ou serem retornada de uma outra função
    Ex.: 
      const sum = function(a, b) {
        return a + b;
      }

      const subtract = function(a, b) {
        return a - b;
      }

      const calculator = function(fn) {
        return function(a, b) {
          return fn(a, b);
        }
      }

      console.log(sum(2, 2)); -> 4
      console.log(subtract(2, 2)); -> 0
      console.log(calculator(sun)(2, 2)); -> 4
      console.log(calculator(subtract)(2, 2)); -> 0
  - É possível invocar uma função com menos ou mais parâmetros, não necessariamente seguindo o que está declarado
    Ex.: 
      const sum = function(a, b) {
        return a + b;
      }
      console.log(sum(2, 2)); -> 4
      console.log(sum(2)); -> NaN -> o JavaScript preenche o segundo parâmetro como undefined, e ao somar 2 + undefined = NaN
      console.log(sum(2, 2, 3)); -> 4 -> Quando se passa mais parâmetros do que a função está esperando, o JavaScript ignora os demais parâmetros
  - Podemos definir valores padrão para cada um dos parâmetros de uma função
    Ex.: 
      const sum = function(a = 1, b = 1) {
        return a + b;
      }
      console.log(sum(2, 2)); -> 4
      console.log(sum(2)); -> 3
      console.log(sum()); -> 2
  - Por meio da variável implícita arguments é possível acessar os parâmetros da função invocada
    Ex.:
      const sum = function() {
        console.log(arguments);
      };

      sum(1, 2, 3, 4, 5, 6, 7, 8, 9); -> { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5, '5': 6, '6': 7, '7': 8, '8': 9 }
    Ex.:
      const sum = function() {
        let total = 0;
        for (let argument in arguments) {
          total += arguments[argument];
        }
        return total;
      };
      console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)); -> 45
  - Também é possível acessar os parâmetros da função invocada por meio do rest parameter
    Ex.:
      const sum = function(...numbers) {
        let total = 0;
        for (let number of numbers) {
          total += number;
        }
        return total;
      };
      console.log(sum(1, 2, 3, 4, 5, 6, 7, 8, 9)); -> 45
  - CUIDADO! O rest parameter deve ser sempre o último da lista de parâmetros

# This
  - Existe uma variável implícita chamada de this que faz referência para o objeto responsável pela sua invocação
    Ex.:
      const rectangle = {
        x: 10,
        y: 2'
        calculateArea() {
          return this.x * this.y;
        }
      };
      console.log(rectangle.calculateArea); -> 20

# getter e setter
  - As funções do tipo getter e setter servem para interceptar o acesso as propriedades de um determinado objeto
    Ex.:
      const rectangle = {
        set x(x) {
          if (x > 0) {
            this._x = x;
          } else {
            console.log("Invalid value for x");
          }
        },
        set y(y) {
          if (y > 0) {
            this._y = y;
          } else {
            console.log("Invalid value for y");
          }
        },
        get area() {
          return this._x * this._y;
        }
      };
      rectangle.x = 10;
      rectangle.y = 2;
      console.log(rectangle.area); -> 20
  - CUIDADO! Sempre utilize chaves diferentes para a função getter e a propriedade do objeto
  - Por meio da operação defineProperty da Object API, também é possível definir funções do tipo getter e setter
    Ex.:
      const rectangle = {};
      Object.defineProperty(rectangle, "x", {
        set(x) {
          if (x > 0) {
            this._x = x;
          } else {
            console.log("Invalid value for x");
          }
        }
      });
      Object.defineProperty(rectangle, "y", {
        set(y) {
          if (y > 0) {
            this._y = y;
          } else {
            console.log("Invalid value for y");
          }
        }
      });
      Object.defineProperty(rectangle, "area", {
        get() {
          return this._x * this._y
        }
      });
      rectangle.x = 10;
      rectangle.y = 2;
      console.log(rectangle.area); -> 20
  - CUIDADO! Sempre utilize chaves diferentes para a função setter e a propriedade do objeto

# call, apply e bind
  - Por meio das operações call e apply é possível invocar uma função passando o this por parâmetro
    Ex.:
      const calculateArea = function() {
        return Math.PI * Math.pow(this.radius, 2);
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      console.log(calculateArea.call(circle)); -> 314.1592653589793
      console.log(calculateArea.apply(circle)); -> 314.1592653589793
  - Qual é a diferença entre call e apply? Basicamente a diferença entre ele é a forma de como passar os parâmetros
    Ex.:
      const calculateArea = function(fn) {
        return fn(Math.PI * Math.pow(this.radius, 2));
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      console.log(calculateArea.call(circle, Math.round)); -> 314
      console.log(calculateArea.apply(circle, [Math.ceil])); -> 314
  - A operação bind permite encapsular o this dentro da função, retornando-a
    Ex.:
      const calculateArea = function(fn) {
        return fn(Math.PI * Math.pow(this.radius, 2));
      };
      const circle = {
        radius: 10,
        calculateArea
      };
      const calculateAreaForCircle = calculateArea.bind(circle);
      console.log(calculateAreaForCircle(Math.round)); -> 314
      console.log(calculateAreaForCircle(Math.ceil)); -> 314
